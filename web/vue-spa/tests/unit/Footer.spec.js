import { createLocalVue, mount } from '@vue/test-utils'
import Footer from '../../src/components/Footer.vue'

const event = {
  target: {
    files: [
      {
        name: 'image.jpg',
        size: 50000,
        type: 'image/jpg'
      }
    ]
  }
}

describe('Footer.vue testing', () => {
  // создаем новый экземпляр Vue приложения с помощью функции  “createLocalVue”
  const vueInstance = createLocalVue()
  // создаем и помещаем в переменную “wrapper” обертку, в которую передаем наш компонент, дополнительно помещая в объект опций созданный экземпляр вью, чтобы  смонтировать и отрендерить наш компонент во Vue-приложении
  const wrapper = mount(Footer, {
    vueInstance
  })
  // используем функцию от Jest “it”, в которой описываем наш первый тест с двумя ожидаемыми результатами:
  it('initialized correctly', () => {
    // ожидаем, что созданная обертка является экземпляром Vue
    expect(wrapper.isVueInstance()).toBe(true)
    // ожидаем, что селектор компонента действительно является “YouTubeWidget”
    expect(wrapper.is(Footer)).toBe(true)
  })
})

describe('Testing limitations of pictures', () => {
  const wrapper = mount(Footer)
  it('initialized correctly', () => {
    const fileReaderSpy = jest.spyOn(FileReader.prototype, 'readAsDataURL').mockImplementation(() => null)
    wrapper.vm.handleFileUpload(event)

    // Assert that the FileReader object was called with the uploaded image
    expect(fileReaderSpy).toHaveBeenCalledWith(event.target.files[0])
  })
})

// Тест план:
// 1) Картинка с допустимыми разрешениями проходит без ошибкой
// 2) Картинка с недопустимым разрешением не загружается и выкидывает ошибку
// 3) Загруженная картинка появляется на экране
// 4) Проверка, что без примененного фильтра текст эффекта = "отсутствует"
// 5) Проверка что эффект сбрасывается в "отсутсвует" при нажатии на кнопку "удалить"
// 6) Проверка, что при нажатии на кнопки выбора типов фильтров меняется список фильтров
// 7) Проверка, что текст эффекта соотвествует примененному эффекту пользователем
// 8) Проверка, что при загрузке нвоого изображения автоматически нажимается кнопка "загрузить" на главном экране
// 9) Проверка, что при нажатии кнопки "удалить", загрузки новой картинки, и обновлении страницы отправляется и выполняется запрос на удаление картинок на сервере
// 10) Проверка, что при загрузке слишком большйо картинки лсит с нейронными фильтрами будет недоступен.
// 11) Проверка, что при нажатии на фильтр, картинка на экране меняется
// 12) Проверка, что при загрузке картинки до применения фильтра кнопки сохранить и сброс недоступны
// 13) Проверка, что при сохранении картинки выполняется сохранение и картинка остаетися на экране
// 14) Проверка, что при сбросе картинки, изменяется изображение на экране и кнопки сохранить и сброс недоступны
// 15) Проверка, что на начальном экране кнопки недоступны
// 16) Проверка, что при последовательным нажатии фильтров будет выдан последний выбранный фильтр
// 17) Проверка, что фильтры до сохранения применяются к изначальному изображению.
// 18) Проверка, что фильтры после сохранения применяются к новому изображению
// 19) Проверка, что картинку с иным форматом (или другой файл в принципе) загрузить невозможно
// 20) Проверка, что при нажатии кнопок появляется окно с предупреждением/пояснением/вопросом
// 21) Проверка, что в поле "разрешение" отображается разрешение картинки
// 22) Проверка, что в поле "название файла" отображается название файла
// 23) Проверка, что при недоступности севрера появляется предупреждение
// 24) Проверка, что при недоступности севрера интерфейс страницы пропадает
// 25) Проверка, что при наведении мышкой фильтр подсвечивается
// 26) Проверка, что при наведении на активную кнопку она также подсвечивается
// 27) Проверка, что при нажатии кнопки "нет" в диалоговом окне оно закрывается и ничего не происходит
// 28) Провекра, что при загрузке изображения загружается интерфйес страницы редактирования
// 29) Проверка, что во время применения фильтра кнопки заблокированы
// 30) Проверка, что во время применения фильтра запускается анимация спиннера
